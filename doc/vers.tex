% -*-LaTeX-*-

\section{Versioning}
\label{sec:vers}

This section describes pFS's model for reconciling different versions
of files when receiving updates asynchronously.

\subsection{Terminology}

We use the term \emph{device} to mean any hardware running the pFS
software.  Though pFS currently only runs on Unix machines, we
envision porting it to other types of hardware such as PDAs, cell
phones, and digital audio players.  Users must supply a unique
symbolic name for each device on which they use pFS (e.g.,
\texttt{market.scs.stanford.edu}, or \texttt{stan-cell-phone}).

A pFS \emph{file system} is a directory tree replicated on one or more
devices.  Each file system has a unique ID, generated randomly at
creation time.  We use the term \emph{replica} to denote a copy of a
particular file system stored by a device.  Note that one device may
store replicas of multiple file systems.

Each replica is also owned by a particular \emph{user}.  Though all
replicas on a portable device would typically be owned by the same
user, this need not be the case on a Unix machine where multiple users
each have accounts they use to access different pFS file systems.
Every replica has a unique name, given by the tuple $\langle
\mathrm{file\ system\ ID}, \mathrm{device}, \mathrm{user}\rangle$.

Each file system has metadata consisting of an access control list and
a set of replicas known to be storing the file system.  The access
control list specifies the users allowed to create and synchronize
replicas of the file system.  Each user specified can have read-only
or read-write access to the file system.  Though currently users are
named by opaque random IDs, eventually we envision naming users by
public keys so as to simplify authentication of device owners.

\subsection{Disconnected Operation}

pFS makes no assumption concerning network partitioning and
connectivity.  We model connectivity as connections happening
opportunistically between two replicas of the same file system.  When
such connections occur, the two replicas send each other all data and
metadata necessary to synchronize their replicas of the file system.
With the current prototype, connections occur when two nodes can reach
each other over the Internet, but the software is structured such that
we can easily add other types of connection, such as USB and Bluetooth
connections.

%concerning a given ressources to be exchanged. We denote such
%connection between $sd_{1}$ and $sd_{2}$ concerning ressource $f$ as
%$c(sd_{1}, sd_{2}, f)$.

Because pFS is essentially permanently in disconnected operation mode,
it must detect and resolve conflicts when multiple replicas of the
same file system are modified between synchronization events.  As with
previous file systems, pFS enforces the ``no lost updates''
guarantee~\cite{page:ficus}---in other words, when reconciling
replicas, pFS will only discard a version of a file if that version's
modification history is a prefix of another version it is not
discarding.

\begin{figure*}
\centerline{\input{pfs_struct}}
\caption{PFS data structures}
\label{fig:struct}
\end{figure*}

Rather than version files and directories, pFS versions directory
entries.  This has two benefits.  First, it simplifies the handling of
cases where the same file name has been concurrently used for a file
on one replica and a directory on another.  Second, it allows us to
simplify the implementation, so that at its core pFS only really has
one complex function, \texttt{pfs\_set\_entry} (discussed in
Subsection~\ref{sec:pfssetentry}), and the rest of the system simply
involves translating file system calls into \texttt{pfs\_set\_entry}
calls.

\subsection{Data structures}

pFS assigns each file and directory a globally unique ID generated
upon creation by hashing the device ID and a counter.  File IDs change
whenever a file changes.  Essentially a file ID identifies an
immutable file version.  By contrast, directories keep the same ID
even when modified.  Otherwise, modifying any file would require
changing all directories up to the root.  Intuitively, the choice of
mutable directory entries also makes sense because pFS reconciles the
meaning of individual file names with a directories, whereas
concurrent updates to the same file are always considered a conflict.

Figure~\ref{fig:struct} shows the basic data structures making up a
directory tree.  Each directory is represented by a \texttt{pfs\_dir}
data structure, containing the directory's unique ID and a set of
\texttt{pfs\_entry} structures.  Each \texttt{pfs\_entry} maps a file
name onto a set of \texttt{pfs\_ver} structures.  When no conflicting
updates have been made to a file, the directory entry has only one
\texttt{pfs\_ver} structure.  However, when reconciling two replicas
with different versions of the file, if one does not supersede
(i.e., reflect the entire modification history of) the other, the
\texttt{pfs\_entry} structure includes a list of all versions required
to preserve the ``no lost update'' guarantee.

Each \texttt{pfs\_ver} contains the file type (regular, directory, or
symbolic link), the ``destination'' ID of the file contents, and
finally a version vector~\cite{parker:inconsistency}.  When the entry
type is a regular file or symbolic link, the destination ID points to
an immutable blob of data.  When the entry type is a directory, the
destination is the ID of another \texttt{pfs\_dir} structure.  A
version vector contains a monotonically increasing version number for
each replica that has modified the directory entry.

If $v$ is a version vector and $r$ is a replica, we write $v[r]$ to
designate the version number assigned by $r$ the last time $r$
modified the resource pointed to by this directory entry.  We say that
a version vector $v_1$ dominates $v_2$ (written $v_1\ge v_2$) iff
$\forall r, v_1[r]\ge v_2[r]$.  Update conflicts are detected when an
entry contains two versions with unordered version vectors---i.e.,
$v_1\not\ge v_2$ and $v_2\not\ge v_1$.  Conversely, when one version's
vector dominates another, it is safe to discard the one whose version
vector is dominated.  These rules are fairly standard for systems
employing version vectors.  However, we note that some file systems,
such as Coda, require more complex version vectors because of the
distinction between replicas and clients~\cite{satyanarayanan:coda}.

\subsubsection{Conflicts}

When a conflict is detected, pFS does not attempt to resolve it
automatically.  Rather, it attempts to expose the conflict to users or
applications by generating two different file names for the two
different versions of the entry. When a conflict is detected for an
entry \texttt{filename}, two (or more) names pointing to two different
ressources are listed:
\begin{center}
{\tt $\mathrm{replica}_1\texttt{:filename}$} \\
{\tt $\mathrm{replica}_2\texttt{:filename}$} \\
\end{center}
Where $\mathrm{replica}_1$ and $\mathrm{replica}_2$ are the names of
the two replicas that created the conflicting directory entries.  pFS
currently reserves the character ``\texttt{:}'' to avoid confusion
between normal and conflicted files.

There has been much work on automatically merging concurrent changes
to the same file.  For instance, Coda has a notion of
application-specific resolvers (ASRs)~\cite{kumar:conflict} that are
fired off automatically based on configuration files and the types of
files with conflicts.  ASRs require support from the file system in
part because conflicts may be detected at servers, yet must be
resolved at clients, and in part because ASRs run with a special view
of the file system allowing them to see conflicted files as
directories containing multiple versions.  Both of these problems are
alleviated in pFS by eliminating the distinction between clients and
servers, and exposing all versions of conflicted files to all users
(by reserving a special character for file names).

When a user (or an application) has resolved a conflict, it must
signal to pFS that a new version of the file now supersedes one of the
other \texttt{pfs\_ver} structures corresponding to that directory
entry.  Users can do this with a utility:
$$\mbox{\texttt{resolve} \emph{old-version} \emph{file}}$$
\texttt{resolve} tells pFS that \emph{file} now contains all the
information needed from \emph{old-version}, so that it is possible to
garbage collect \emph{old-version} without violating the ``no lost
updates'' guarantee.  pFS handles this request internally by setting
the version vector of file $v_f$ to the element-wise maximum of its
old value and \emph{old-file}'s version vector, $v_o$:
$$\mathbf{foreach}\>r:v_f[r]\gets\max(v_f[r],v_o[r])$$

%% information from the two different
%% versions has been inserted by the user or an application into one of
%% the versions of the entry,

%% invoking:
%% \begin{center} 
%% {\tt rename (name($sd_{j}$):f,name($sd_{i}$):f)}
%% \end{center}
%%  deletes entry version {\tt name($sd_{j}$):f} along with the
%%  underlying ressource and updates 
%% {\tt name($sd_{i}$):f}'s version vector. The underlying content of 
%% {\tt name($sd_{i}$):f} stay unchanged, since the actual merging
%% operation has to be done before calling {\tt rename}.
%% If the two initial version vectors where
%% $vv^{(i)}=(sd_{k},v_{k}^{(i)})_{k}$ and
%%   $vv^{(j)}=(sd_{k},v_{k}^{(j)})_{k}$, The resulting version
%% vector is 
%% \begin{center}
%% $vv^{(i \leftarrow j)}=(sd_{k},
%% max(v_{k}^{(i)},v_{k}^{(j)}) + \delta _{i}^{k})_{k}$
%% \end{center}
%% The resulting version vector dominates both original version vectors
%% and count one update for this merging operation for $sd_{i}$.


The mechanism for requesting that pFS update a version vector is
simply to make the {\tt rename} system call on file names containing
the special reserved ``\texttt{:}'' character.  The actual merging of
data into \emph{file} is also done with ordinary file system
calls---namely reading \emph{old-version} and overwriting \emph{file}.
Thus, no special interfaces are required to resolve conflicts.  In
fact, \texttt{resolve} is nothing but a tiny shell script calling
\texttt{mv}.  This also means that applications aware of pFS can do
their own conflict resolution.  In fact, a mechanism similar to Coda's
ASRs could be implemented entirely outside of the file system (except
users would have to launched it manually on a directory tree after a
synchronization event).

%Hence, users are able to detect conflicts, resolve them manually or
%automatically using third-party application, and merge the two
%versions into a final version that supersedes them. All those
%operations can be expressed through the classical file
%system interface and therefore require absolutely no change to
%existing terminals and utilities.

\subsubsection{Main Version}

To avoid the proliferation of entry versions, we introduce the notion
of \emph{main version}. We define an order $<_{sd_{i}}$ relative to
$sd_{i}$ over the versions of a given entry :

\begin{definition}
We say that $vv^{(1)} >_{sd_{i}} vv^{(2)}$ if the update count
relative to $sd_{i}$ is greater in $vv^{(1)}$ than it is in
$vv^{(2)}$. Or if those quantities are equals, if the total number
of updates is greater in $vv^{(1)}$ than it is in $vv^{(2)}$.
\end{definition}
 
We can always determine for each $sd$ a maximum version verctor (by
breaking the ties arbitrarly if two or more candidates are
``equals''). We call the associated entry version the main version for
that $sd$.

When multiple versions of an entry named {\tt f} coexist, we display
the main version as {\tt f} and the other version as before :
\begin{center}
  {\tt f} \\
  {\tt name($sd_{i}$):f} \\
  {\tt ...}
\end{center}
Moreover pFS enforces that only the main version of an entry is
writable, the other ones being accessible read-only.
Therefore, merging process is achieved by inserting into the main
version of an entry all the information contained in another version,
and then calling :
\begin{center}
{\tt rename (name($sd_{j}$):f, f)}.
\end{center}
Under such restrictions, a $sd$ can only be the last updater of its
main version, and the total number of versions seen by a $sd$ for any
given entry is bounded by the number of $sd$s participating in the group.
{\proof
Suppose we have $k$ version vectors, $vv^{(1)},..., vv^{(k)}$ for an
entry $f$ at a given $sd$, and $n$ $sd$s, $sd_{1}, ..., sd_{n}$
participating in the group. A new version vector can only be generated
by updating an entry or merging two entry versions, and the resutling
version vector is necessarely the main version vector of the $sd$
where the update occured. Therefore, for each version vector
$vv^{(i)}$, it exists $l$ such that $sd_{l}$ has $vv^{(i)}$ as main
version vector relatively to the set $vv^{(1)},..., vv^{(k)}$. If it
exists $vv^{(i)},vv^{(j)}$ such that $sd_{l}$ has $vv^{(i)}$ and
$vv^{(j)}$ as main version vector, then one dominates the other and
$i=j$. Thus, $k \leq n$. \qed
}

Note that the set $vv^{(1)},..., vv^{(k)}$ can differ from one $sd$ to
the other if all updates are not yet propagated to all $sd$s. Table \ref{VVEx}
shows the evolution of the version vectors associated with an
entry updated from three different $sd$s.

\subsection {${\tt pfs\_set\_entry}$}
\label{sec:pfssetentry}

A nice property of this versionning system is that all modifications
made through the traditional Unix file system interface can be
straight-forwardly translated into invocations of a single function,
{\tt pfs\_set\_entry}.  {\tt pfs\_set\_entry} is the atomic update
operation that will be propagated among the replicas of a file system.
pFS logs these operations, and replaying them sequentially
reconstructs the associated file system structures.  When
synchronizing with another replica, the updates are applied and can be
simply appended to a log for further propagation to other replicas.
However, entries with whose version vectors are dominated by other
(later) versions never need to be propagated to other replicas.

The function's prototype is as follows:

\begin{center}
{\tt \small
\begin{verbatim}
int pfs_set_entry 
  (struct pfs_instance *pfs,
   const char *file_system,
   const char *dir_id,
   const char *name,
   const struct pfs_ver *ver,
   const bool_t reclaim);
\end{verbatim}
}
\end{center}

{\tt pfs\_set\_entry} adds version {\tt ver} (see
Figure~\ref{MemStruct} for a declaration of {\tt pfs\_ver} structure)
to the entry {\tt name} in the directory designated by {\tt dir\_id}
in the file system designated by {\tt file\_system}.  Note that the
directory structure does not have a name, but is simply designated by
its {\tt dir\_id}.  (The directory's name is mapped to {\tt dir\_id}
in the parent directory, and the root directory ID is stored in the
file system metadata.)

Recall that a \texttt{pfs\_ver} structure has a \texttt{dst\_id} field
that references a blob of data (for regular files and symbolic links),
or another directory.  The {\tt reclaim} argument simply specifies
whether or not the object referenced by the previous value of
\texttt{dst\_id} can be garbage collected (which it usually can,
except with rename where the same \texttt{dst\_id} field will be
inserted into the destination directory entry).

Let us show a few examples of how file system operations map to {\tt
pfs\_set\_entry} operations.  For simplicity, we ignore the {\tt pfs}
and {\tt file\_system} arguments, which are identical for all calls
within a file system.  We also show \texttt{pfs\_ver} structures
within braces, and omit the version vector.

\begin{itemize}
  \item \textbf{open ($f$, O\_CREAT, 0666)}: \\
    generate a new back-end storage file (blob) and $id$ \\
    {\tt pfs\_set\_entry ($dir\_id$,$f$,$\{$REG, $id$$\}$,1)}

  \item \textbf{close ($f$)} when $f$ is dirty: \\
    regenerate back-end storage $id'$ \\
    {\tt pfs\_set\_entry ($dir\_id$,$f$,$\{$REG, $id'$$\}$,1)}
    
  \item \textbf{unlink ($f$)}: \\
    {\tt pfs\_set\_entry ($dir\_id$,$f$,$\{$DEL, 0$\}$,1)}

  \item \textbf{rmdir ($d$)}: \\
    {\tt pfs\_set\_entry ($dir\_id$,$d$,$\{$DEL, 0$\}$,1)}

  \item \textbf{rename ($f_1$, $f_2$)}: \\
    {\tt pfs\_set\_entry ($dir\_id_2$,$f_2$,$\{$REG, $id$$\}$,1)} \\
    {\tt pfs\_set\_entry ($dir\_id_1$,$f_1$,$\{$DEL, 0$\}$,0)}
\end{itemize}

We have not shown the version vectors used here. They are generated or
incremented according to the semantics we defined previously. Note
that a deleted entry persists in the system with a \texttt{pfs\_ver}
of type {\tt DEL}\@.  This conservative technique is needed to handle
cases where an entry might have been deleted on one replica and
updated on another. The {\tt DEL} type has to be treated as any other
type of entry by the versionning system.

% --- XXX needs work below

In the future, we may use
vector time pairs~\cite{cox:tra} to alleviate the need to track
deleted files.

Whenever a {\tt pfs\_set\_entry} update is received from another
replica and the {\tt dir\_id} is unknown to the receiver, the receiver
generates a new, dangling {\tt pfs\_dir} structure which is not
reachable from the local root directory, but at least allows the
synchronization operation to complete.

Such situation may arise if the updates are not propagated according
to the same order as the one they have been originally generated
with. If all updates are subsequently propagated, an update relative
to the new directory will follow and will allow its insertion in the
local tree. This behavior gives the {\tt pfs\_set\_entry} updates a
very useful property : \emph{a given set of updates will result in the
same local tree structure regardless of the order in which the updates
are performed.}

Updates are naturally ordered by the Happen-Before relationship, and
one can advocate to keep this order whenever a set of updates is
propagated. Nevertheless, we rely explicitly on the order independance
described above in one precise case : directory removal. Assume
$sd_{1}$ and $sd_{2}$ are disconnected, $sd_{1}$ removes a
directory $d$ and the one file contained in it $f$, while $sd_{2}$
makes a modification to $f$. When $sd_{2}$ will receive $sd_{1}$
updates, $f$ will first exist as two non-dominated versions, a file
and a a deleted entry. Then an attempt will be made to remove
directory $d$ which will fail since $d$ is not empty on $sd_{2}$. Here
$sd_{2}$ has to replay $d$ creation with an increased version
vector. When $sd_{2}$ updates will be propagated to $sd_{1}$, it will
first see the creation of a file $f$ for an unknown {\tt dir\_id}, and
will accept the update and generate a new directory with the unknown
{\tt dir\_id}. Then, it will receive the replayed creation of $d$,
allowing it to reinsert the mapping from name $d$ to {\tt dir\_id}, into
the parent directory. Finally, $d$ maps on every $sd$ to two non-dominated
versions, $(DEL,0)$ as main version for $sd_{1}$ and, $(DIR, dir\_id)$ as main version
for $sd_{2}$.

%QUID : Do you see the little consistency that exists after this
%operation. It has no impact on the logical structure of the
%tree...
%Should I mention it ?

Other solutions could have been provided to solve this directory
removal problem. All other programation of updates we considered would
have implied loosing the log structure of {\tt pfs\_set\_entry}
updates which we believe has to be preserved for its simplicity and
the flexibility it provides for updates propagation.

Thus, {\tt pfs\_set\_entry} is the atomic update operation used by
pFS. Any modification to the file system tree structure can be mapped
to a {\tt pfs\_set\_entry} update. The updates are organized as a
simple order-independent log structure, which provides a great deal of
flexibility and simplicity for updates propagation.

\begin{figure}[t]
\begin{center}
{\tt \small
\begin{verbatim}
struct pfs_dir
{
  char id [PFS_ID_LEN];
  uint32_t entry_cnt;
  struct pfs_entry ** entry;
};
struct pfs_entry
{
  char name [PFS_NAME_LEN];
  uint32_t main_idx;
  uint32_t ver_cnt; 
  struct pfs_ver ** ver;
};
enum pfs_entry_type {
  PFS_DEL = 0,
  PFS_FIL = 1,
  PFS_DIR = 2,
  PFS_SML = 3 
};
struct pfs_ver
{
  uint8_t type;
  char dst_id [PFS_ID_LEN];
  struct pfs_vv * vv;
};
struct pfs_vv
{ 
  char last_updt [PFS_ID_LEN];
  uint32_t len;
  char ** sd_id;
  uint32_t * value;
};
\end{verbatim}
}
\end{center}
\caption{\label{MemStruct}
{\small In-memory data structures for directory, entries and version
  vectors.}}
\end{figure}

\begin{table*}[t]
\begin{center}
  \begin{tabular}[t]{|l||cc|cc|cc|}
    \hline
    \emph{ops} & $sd_{1}$ & & $sd_{2}$ & & $sd_{3}$ & \\
    \hline

    $sd_{1} : f_{\text{create}}$ & 
    $\langle 1,0,0\rangle$ & &
     & &
     & \\

    $c(sd_{1},sd_{2},f)$ &
    $\langle 1,0,0 \rangle$ & &
    $\langle 1,0,0 \rangle$ & &
     & \\

    $sd_{2} : f_{\text{modif}}$ & 
    & &
    $\langle 1,1,0 \rangle$ & &
     & \\

    $sd_{1} : f_{\text{modif}}$ &
    $\langle 2,0,0 \rangle$ & &
    & &
     & \\

    $c(sd_{2},sd_{3},f)$ &
    & & 
    $\langle 1,1,0 \rangle$ & &
    $\langle 1,1,0 \rangle$ & \\

    $c(sd_{1},sd_{3},f)$ &
    $\langle 2,0,0 \rangle$ & $\langle 1,1,0 \rangle$ &
    & &
    $\langle 1,1,0 \rangle$ & $\langle 2,0,0 \rangle$ \\

    $sd_{3} : f_{\text{modif}}$ &
    & &
    & & 
    $\langle 1,1,1 \rangle$ & $\langle 2,0,0 \rangle$ \\

    $c(sd_{2},sd_{3},f)$ &
    & &
    $\langle 1,1,1 \rangle$ & $\langle 2,0,0 \rangle$ & 
    $\langle 1,1,1 \rangle$ & $\langle 2,0,0 \rangle$ \\

    $sd_{2} : f_{\langle 1,1,1 \rangle \leftarrow \langle 2,0,0 \rangle}$ &
    & &
    $\langle 2,2,1 \rangle$ & &
    & \\

    $c(sd_{1},sd_{2},f)$ &
    $\langle 2,2,1 \rangle$ & &
    $\langle 2,2,1 \rangle$ & & 
    & \\

    $c(sd_{1},sd_{3})$ &
    $\langle 2,2,1 \rangle$ & &
    & &
    $\langle 2,2,1 \rangle$ & \\

    \hline
  \end{tabular}
\end{center}
\caption{\label{VVEx}
  {\small Evolution of version vectors for a file $f$ modified from
  three different $sd$s. For each $sd$ we show the main version
  vector relative to that $sd$ fisrt. We show the version vector list
  for each $sd$ only when it is modified.
  Here the maximum number of
  coexisting versions for $f$ is 2. We could have reached the worst
  case, that is 3, by modifying $f$ from the three different $sd$s
  without any connection occuring between modifications.}}
\end{table*}

% Local Variables:
% tex-main-file: "main.ltx"
% tex-command: "make;:"
% tex-dvi-view-command: "make preview;:"
% End:
